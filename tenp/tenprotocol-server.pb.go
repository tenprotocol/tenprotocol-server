// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tenprotocol-server.proto

package tenp

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// /.well-known/threat-exposure-configuration
type ConfigurationDocument struct {
	// REQUIRED.  Boolean value indicating whether the server supports
	// the Query operation.
	SupportsQuery bool `protobuf:"varint,1,opt,name=supports_query,json=supportsQuery,proto3" json:"supports_query,omitempty"`
	// RECOMMENDED.  URL of the server's Query endpoint.
	QueryEndpoint string `protobuf:"bytes,2,opt,name=query_endpoint,json=queryEndpoint,proto3" json:"query_endpoint,omitempty"`
	// REQUIRED.  Boolean value indicating whether the server supports
	// the Upload operation.
	SupportsUpload bool `protobuf:"varint,3,opt,name=supports_upload,json=supportsUpload,proto3" json:"supports_upload,omitempty"`
	// RECOMMENDED.  URL of the server's Fetch endpoint.
	UploadEndpoint string `protobuf:"bytes,4,opt,name=upload_endpoint,json=uploadEndpoint,proto3" json:"upload_endpoint,omitempty"`
	// REQUIRED.  Boolean value indicating whether the server supports
	// the Fetch operation.
	SupportsFetch bool `protobuf:"varint,5,opt,name=supports_fetch,json=supportsFetch,proto3" json:"supports_fetch,omitempty"`
	// RECOMMENDED.  URL of the server's Query endpoint.
	FetchEndpoint string `protobuf:"bytes,6,opt,name=fetch_endpoint,json=fetchEndpoint,proto3" json:"fetch_endpoint,omitempty"`
	// REQUIRED.  Boolean value indicating whether the server supports
	// the Revoke operation.
	SupportsRevoke bool `protobuf:"varint,7,opt,name=supports_revoke,json=supportsRevoke,proto3" json:"supports_revoke,omitempty"`
	// RECOMMENDED.  URL of the server's Revoke endpoint.
	RevokeEndpoint string `protobuf:"bytes,8,opt,name=revoke_endpoint,json=revokeEndpoint,proto3" json:"revoke_endpoint,omitempty"`
	// REQUIRED.  An array of strings of the threats the server supports.
	ThreatsSupported []string `protobuf:"bytes,9,rep,name=threats_supported,json=threatsSupported,proto3" json:"threats_supported,omitempty"`
	// REQUIRED.  An array of strings of the keys the server supports.
	KeysSupported []string `protobuf:"bytes,10,rep,name=keys_supported,json=keysSupported,proto3" json:"keys_supported,omitempty"`
	// RECOMMENDED.  An array of strings of the Assertions the server
	// supports.
	AssertionsSupported []string `protobuf:"bytes,11,rep,name=assertions_supported,json=assertionsSupported,proto3" json:"assertions_supported,omitempty"`
}

func (m *ConfigurationDocument) Reset()      { *m = ConfigurationDocument{} }
func (*ConfigurationDocument) ProtoMessage() {}
func (*ConfigurationDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2c09c3f7c01dbc, []int{0}
}
func (m *ConfigurationDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigurationDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigurationDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigurationDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationDocument.Merge(m, src)
}
func (m *ConfigurationDocument) XXX_Size() int {
	return m.Size()
}
func (m *ConfigurationDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationDocument.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationDocument proto.InternalMessageInfo

func (m *ConfigurationDocument) GetSupportsQuery() bool {
	if m != nil {
		return m.SupportsQuery
	}
	return false
}

func (m *ConfigurationDocument) GetQueryEndpoint() string {
	if m != nil {
		return m.QueryEndpoint
	}
	return ""
}

func (m *ConfigurationDocument) GetSupportsUpload() bool {
	if m != nil {
		return m.SupportsUpload
	}
	return false
}

func (m *ConfigurationDocument) GetUploadEndpoint() string {
	if m != nil {
		return m.UploadEndpoint
	}
	return ""
}

func (m *ConfigurationDocument) GetSupportsFetch() bool {
	if m != nil {
		return m.SupportsFetch
	}
	return false
}

func (m *ConfigurationDocument) GetFetchEndpoint() string {
	if m != nil {
		return m.FetchEndpoint
	}
	return ""
}

func (m *ConfigurationDocument) GetSupportsRevoke() bool {
	if m != nil {
		return m.SupportsRevoke
	}
	return false
}

func (m *ConfigurationDocument) GetRevokeEndpoint() string {
	if m != nil {
		return m.RevokeEndpoint
	}
	return ""
}

func (m *ConfigurationDocument) GetThreatsSupported() []string {
	if m != nil {
		return m.ThreatsSupported
	}
	return nil
}

func (m *ConfigurationDocument) GetKeysSupported() []string {
	if m != nil {
		return m.KeysSupported
	}
	return nil
}

func (m *ConfigurationDocument) GetAssertionsSupported() []string {
	if m != nil {
		return m.AssertionsSupported
	}
	return nil
}

type Diagnosis struct {
	// REQUIRED.  A URI of a threat that has been diagnosed, as
	// specified inSection 4.
	Threat string `protobuf:"bytes,1,opt,name=threat,proto3" json:"threat,omitempty"`
	// REQUIRED.  The time when the diagnosis was made formatted as
	// specified in [RFC3339] with no time zone offset.
	Diagnosed string `protobuf:"bytes,2,opt,name=diagnosed,proto3" json:"diagnosed,omitempty"`
}

func (m *Diagnosis) Reset()      { *m = Diagnosis{} }
func (*Diagnosis) ProtoMessage() {}
func (*Diagnosis) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2c09c3f7c01dbc, []int{1}
}
func (m *Diagnosis) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Diagnosis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Diagnosis.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Diagnosis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Diagnosis.Merge(m, src)
}
func (m *Diagnosis) XXX_Size() int {
	return m.Size()
}
func (m *Diagnosis) XXX_DiscardUnknown() {
	xxx_messageInfo_Diagnosis.DiscardUnknown(m)
}

var xxx_messageInfo_Diagnosis proto.InternalMessageInfo

func (m *Diagnosis) GetThreat() string {
	if m != nil {
		return m.Threat
	}
	return ""
}

func (m *Diagnosis) GetDiagnosed() string {
	if m != nil {
		return m.Diagnosed
	}
	return ""
}

type UploadRequest struct {
	// REQUIRED. A URI of a key type.
	KeyType string `protobuf:"bytes,1,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
	// REQUIRED. An array of strings representing the diagnosis keys
	// for that key type.
	Keys []string `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	// REQUIRED.  An object providing information about the diagnosis of
	// a threat.
	Diagnosis *Diagnosis `protobuf:"bytes,3,opt,name=diagnosis,proto3" json:"diagnosis,omitempty"`
	// OPTIONAL.  An object providing additional assertions related to
	// the upload, diagnosis, individual or scope.  The key is an
	// Assertion defined as perSection 5.  The client MUST ignore any
	// assertions it does not recognize.
	Assertions map[string]string `protobuf:"bytes,4,rep,name=assertions,proto3" json:"assertions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *UploadRequest) Reset()      { *m = UploadRequest{} }
func (*UploadRequest) ProtoMessage() {}
func (*UploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2c09c3f7c01dbc, []int{2}
}
func (m *UploadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadRequest.Merge(m, src)
}
func (m *UploadRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadRequest proto.InternalMessageInfo

func (m *UploadRequest) GetKeyType() string {
	if m != nil {
		return m.KeyType
	}
	return ""
}

func (m *UploadRequest) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *UploadRequest) GetDiagnosis() *Diagnosis {
	if m != nil {
		return m.Diagnosis
	}
	return nil
}

func (m *UploadRequest) GetAssertions() map[string]string {
	if m != nil {
		return m.Assertions
	}
	return nil
}

type QueryRequest struct {
	// REQUIRED. A URI of a key type.
	KeyType string `protobuf:"bytes,1,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
	// REQUIRED. An array of strings representing the potential exposure
	// keys for that key type.
	Keys []string `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	// OPTIONAL. A time to search for diagnosis keys uploaded up to and before,
	// formatted as specified in [RFC3339] with no time zone offset. If omitted,
	// the server SHOULD use latest. Searches SHOULD be done inclusive of this time.
	Before string `protobuf:"bytes,3,opt,name=before,proto3" json:"before,omitempty"`
	// OPTIONAL. A time to search for diagnosis keys uploaded after,
	// formatted as specified in [RFC3339] with no time zone offset. If omitted,
	// the server SHOULD provide a reasonable default based on the specified threats.
	// Searches SHOULD be done exclusive of this time.
	After string `protobuf:"bytes,4,opt,name=after,proto3" json:"after,omitempty"`
	// REQUIRED.  A threat URI as defined in Section 4, specifying which
	// threat to check for exposure.
	Threat string `protobuf:"bytes,5,opt,name=threat,proto3" json:"threat,omitempty"`
	// OPTIONAL.  An object providing additional assertions related to
	// the upload, diagnosis, individual or scope.  The key is an
	// Assertion defined as perSection 5.  The client MUST ignore any
	// assertions it does not recognize.
	Assertions map[string]string `protobuf:"bytes,6,rep,name=assertions,proto3" json:"assertions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *QueryRequest) Reset()      { *m = QueryRequest{} }
func (*QueryRequest) ProtoMessage() {}
func (*QueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2c09c3f7c01dbc, []int{3}
}
func (m *QueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRequest.Merge(m, src)
}
func (m *QueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRequest proto.InternalMessageInfo

func (m *QueryRequest) GetKeyType() string {
	if m != nil {
		return m.KeyType
	}
	return ""
}

func (m *QueryRequest) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *QueryRequest) GetBefore() string {
	if m != nil {
		return m.Before
	}
	return ""
}

func (m *QueryRequest) GetAfter() string {
	if m != nil {
		return m.After
	}
	return ""
}

func (m *QueryRequest) GetThreat() string {
	if m != nil {
		return m.Threat
	}
	return ""
}

func (m *QueryRequest) GetAssertions() map[string]string {
	if m != nil {
		return m.Assertions
	}
	return nil
}

type WebLink struct {
	// The value of the "rel" member is a string that is either a URI or a
	// registered relation type [8] (see RFC 5988 [4])
	Rel string `protobuf:"bytes,1,opt,name=rel,proto3" json:"rel,omitempty"`
	// The value of the "type" member is a string that indicates the media
	// type [9] of the target resource (see RFC 6838 [10]).
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// The value of the "href" member is a string that contains a URI
	// pointing to the target resource.
	Href string `protobuf:"bytes,3,opt,name=href,proto3" json:"href,omitempty"`
	// The "titles" object comprises zero or more name/value pairs whose
	// names are a language tag [11] or the string "und"
	Titles map[string]string `protobuf:"bytes,4,rep,name=titles,proto3" json:"titles,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The "properties" object within the link relation object comprises
	// zero or more name/value pairs whose names are URIs (referred to as
	// "property identifiers") and whose values are strings or null.
	Properties map[string]string `protobuf:"bytes,5,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *WebLink) Reset()      { *m = WebLink{} }
func (*WebLink) ProtoMessage() {}
func (*WebLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2c09c3f7c01dbc, []int{4}
}
func (m *WebLink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebLink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WebLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebLink.Merge(m, src)
}
func (m *WebLink) XXX_Size() int {
	return m.Size()
}
func (m *WebLink) XXX_DiscardUnknown() {
	xxx_messageInfo_WebLink.DiscardUnknown(m)
}

var xxx_messageInfo_WebLink proto.InternalMessageInfo

func (m *WebLink) GetRel() string {
	if m != nil {
		return m.Rel
	}
	return ""
}

func (m *WebLink) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *WebLink) GetHref() string {
	if m != nil {
		return m.Href
	}
	return ""
}

func (m *WebLink) GetTitles() map[string]string {
	if m != nil {
		return m.Titles
	}
	return nil
}

func (m *WebLink) GetProperties() map[string]string {
	if m != nil {
		return m.Properties
	}
	return nil
}

type QueryResponse struct {
	// REQUIRED. A URI of a key type.
	KeyType string `protobuf:"bytes,1,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
	// REQUIRED. A boolean denoting whether an exposure to the threat
	// has been flagged.
	Exposed bool `protobuf:"varint,2,opt,name=exposed,proto3" json:"exposed,omitempty"`
	// OPTIONAL.  An array of days when exposures happened formatted as
	// per [RFC3339] without a time component.
	Exposures []string `protobuf:"bytes,3,rep,name=exposures,proto3" json:"exposures,omitempty"`
	// REQUIRED. The time of the most recent upload across all diagnosis
	// keys considered. This MAY be used in a subsequent query as "after"
	// to page through results.
	Before string `protobuf:"bytes,4,opt,name=before,proto3" json:"before,omitempty"`
	// OPTIONAL. The time of the the oldest upload across all diagnosis keys
	// considered.
	After string `protobuf:"bytes,5,opt,name=after,proto3" json:"after,omitempty"`
	// REQUIRED. A threat URI as defined in Section 4 specifying which threat to
	// check for exposure.
	Threat string `protobuf:"bytes,6,opt,name=threat,proto3" json:"threat,omitempty"`
	// A human-readable message to be displayed to the user.
	Message string `protobuf:"bytes,7,opt,name=message,proto3" json:"message,omitempty"`
	// A list of WebLinks [RFC8288] for more information.
	Links []*WebLink `protobuf:"bytes,8,rep,name=links,proto3" json:"links,omitempty"`
}

func (m *QueryResponse) Reset()      { *m = QueryResponse{} }
func (*QueryResponse) ProtoMessage() {}
func (*QueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2c09c3f7c01dbc, []int{5}
}
func (m *QueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResponse.Merge(m, src)
}
func (m *QueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResponse proto.InternalMessageInfo

func (m *QueryResponse) GetKeyType() string {
	if m != nil {
		return m.KeyType
	}
	return ""
}

func (m *QueryResponse) GetExposed() bool {
	if m != nil {
		return m.Exposed
	}
	return false
}

func (m *QueryResponse) GetExposures() []string {
	if m != nil {
		return m.Exposures
	}
	return nil
}

func (m *QueryResponse) GetBefore() string {
	if m != nil {
		return m.Before
	}
	return ""
}

func (m *QueryResponse) GetAfter() string {
	if m != nil {
		return m.After
	}
	return ""
}

func (m *QueryResponse) GetThreat() string {
	if m != nil {
		return m.Threat
	}
	return ""
}

func (m *QueryResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *QueryResponse) GetLinks() []*WebLink {
	if m != nil {
		return m.Links
	}
	return nil
}

type FetchRequest struct {
	// REQUIRED.  A URI for the requested key type.
	KeyType string `protobuf:"bytes,1,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
	// OPTIONAL.  A date to search for exposures before, formatted as
	// specified in [RFC3339] with no time zone offset. If omitted,
	// the server SHOULD use latest. Searches SHOULD be done inclusive
	// of this time.
	Before string `protobuf:"bytes,2,opt,name=before,proto3" json:"before,omitempty"`
	// OPTIONAL.  A date to search for exposures after, formatted as
	// specified in [RFC3339] with no time zone offset.  If omitted, the
	// server SHOULD provide a reasonable default based on the specified
	// threats. Searches SHOULD be done exclusive of this time.
	After string `protobuf:"bytes,3,opt,name=after,proto3" json:"after,omitempty"`
	// REQUIRED.  A threat URI as defined in Section 4 specifying which
	// threat to check for exposure.
	Threat string `protobuf:"bytes,4,opt,name=threat,proto3" json:"threat,omitempty"`
	// OPTIONAL.  An object providing additional assertions related to
	// the upload, diagnosis, individual or scope.  The key is an
	// Assertion defined as per Section 5.  The client MUST ignore any
	// assertions it does not recognize.
	Assertions map[string]string `protobuf:"bytes,5,rep,name=assertions,proto3" json:"assertions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FetchRequest) Reset()      { *m = FetchRequest{} }
func (*FetchRequest) ProtoMessage() {}
func (*FetchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2c09c3f7c01dbc, []int{6}
}
func (m *FetchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchRequest.Merge(m, src)
}
func (m *FetchRequest) XXX_Size() int {
	return m.Size()
}
func (m *FetchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchRequest proto.InternalMessageInfo

func (m *FetchRequest) GetKeyType() string {
	if m != nil {
		return m.KeyType
	}
	return ""
}

func (m *FetchRequest) GetBefore() string {
	if m != nil {
		return m.Before
	}
	return ""
}

func (m *FetchRequest) GetAfter() string {
	if m != nil {
		return m.After
	}
	return ""
}

func (m *FetchRequest) GetThreat() string {
	if m != nil {
		return m.Threat
	}
	return ""
}

func (m *FetchRequest) GetAssertions() map[string]string {
	if m != nil {
		return m.Assertions
	}
	return nil
}

type FetchResponse struct {
	// REQUIRED. A URI of a key type.
	KeyType string `protobuf:"bytes,1,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
	// REQUIRED. An array of strings representing the diagnosis keys
	// for that key type.
	Keys []string `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	// REQUIRED. The time of the most recent upload across all diagnosis keys
	// considered. This MAY be used in subsequent fetch requests to page through results.
	Before string `protobuf:"bytes,3,opt,name=before,proto3" json:"before,omitempty"`
	// OPTIONAL. The time of the the oldest upload across all diagnosis keys considered.
	After string `protobuf:"bytes,4,opt,name=after,proto3" json:"after,omitempty"`
	// REQUIRED.  A threat URI as defined in Section 4 specifying which
	// threat to check for exposure.
	Threat string `protobuf:"bytes,5,opt,name=threat,proto3" json:"threat,omitempty"`
}

func (m *FetchResponse) Reset()      { *m = FetchResponse{} }
func (*FetchResponse) ProtoMessage() {}
func (*FetchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2c09c3f7c01dbc, []int{7}
}
func (m *FetchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchResponse.Merge(m, src)
}
func (m *FetchResponse) XXX_Size() int {
	return m.Size()
}
func (m *FetchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FetchResponse proto.InternalMessageInfo

func (m *FetchResponse) GetKeyType() string {
	if m != nil {
		return m.KeyType
	}
	return ""
}

func (m *FetchResponse) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *FetchResponse) GetBefore() string {
	if m != nil {
		return m.Before
	}
	return ""
}

func (m *FetchResponse) GetAfter() string {
	if m != nil {
		return m.After
	}
	return ""
}

func (m *FetchResponse) GetThreat() string {
	if m != nil {
		return m.Threat
	}
	return ""
}

type RevokeRequest struct {
	// REQUIRED. A URI of a key type.
	KeyType string `protobuf:"bytes,1,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
	// REQUIRED. An array of strings representing the diagnosis keys
	// for that key type.
	Keys []string `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	// OPTIONAL.  An object providing additional assertions related to
	// the upload, diagnosis, individual or scope.  The key is an
	// Assertion defined as per Section 5.  The client MUST ignore any
	// assertions it does not recognize.
	Assertions map[string]string `protobuf:"bytes,3,rep,name=assertions,proto3" json:"assertions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RevokeRequest) Reset()      { *m = RevokeRequest{} }
func (*RevokeRequest) ProtoMessage() {}
func (*RevokeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2c09c3f7c01dbc, []int{8}
}
func (m *RevokeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RevokeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RevokeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RevokeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevokeRequest.Merge(m, src)
}
func (m *RevokeRequest) XXX_Size() int {
	return m.Size()
}
func (m *RevokeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RevokeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RevokeRequest proto.InternalMessageInfo

func (m *RevokeRequest) GetKeyType() string {
	if m != nil {
		return m.KeyType
	}
	return ""
}

func (m *RevokeRequest) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *RevokeRequest) GetAssertions() map[string]string {
	if m != nil {
		return m.Assertions
	}
	return nil
}

func init() {
	proto.RegisterType((*ConfigurationDocument)(nil), "tenp.ConfigurationDocument")
	proto.RegisterType((*Diagnosis)(nil), "tenp.Diagnosis")
	proto.RegisterType((*UploadRequest)(nil), "tenp.UploadRequest")
	proto.RegisterMapType((map[string]string)(nil), "tenp.UploadRequest.AssertionsEntry")
	proto.RegisterType((*QueryRequest)(nil), "tenp.QueryRequest")
	proto.RegisterMapType((map[string]string)(nil), "tenp.QueryRequest.AssertionsEntry")
	proto.RegisterType((*WebLink)(nil), "tenp.WebLink")
	proto.RegisterMapType((map[string]string)(nil), "tenp.WebLink.PropertiesEntry")
	proto.RegisterMapType((map[string]string)(nil), "tenp.WebLink.TitlesEntry")
	proto.RegisterType((*QueryResponse)(nil), "tenp.QueryResponse")
	proto.RegisterType((*FetchRequest)(nil), "tenp.FetchRequest")
	proto.RegisterMapType((map[string]string)(nil), "tenp.FetchRequest.AssertionsEntry")
	proto.RegisterType((*FetchResponse)(nil), "tenp.FetchResponse")
	proto.RegisterType((*RevokeRequest)(nil), "tenp.RevokeRequest")
	proto.RegisterMapType((map[string]string)(nil), "tenp.RevokeRequest.AssertionsEntry")
}

func init() { proto.RegisterFile("tenprotocol-server.proto", fileDescriptor_8e2c09c3f7c01dbc) }

var fileDescriptor_8e2c09c3f7c01dbc = []byte{
	// 1123 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x4d, 0x6f, 0xe3, 0x44,
	0x18, 0x8e, 0x9d, 0x8f, 0x26, 0x93, 0x4d, 0x3f, 0x26, 0xa5, 0x78, 0x03, 0x98, 0xac, 0x2b, 0x44,
	0xb5, 0xa8, 0x4e, 0xdb, 0xbd, 0x40, 0xa4, 0x95, 0x68, 0x77, 0xcb, 0x05, 0x58, 0x81, 0x5b, 0x84,
	0xc4, 0xa5, 0x72, 0x92, 0x37, 0x89, 0x49, 0xea, 0xf1, 0xce, 0x8c, 0x5b, 0xc2, 0x09, 0x21, 0xc4,
	0x19, 0x81, 0xf8, 0x0f, 0xdc, 0xf8, 0x0f, 0x9c, 0xb8, 0x80, 0x2a, 0x71, 0xd9, 0x13, 0xa2, 0x29,
	0x12, 0x1c, 0x17, 0x7e, 0x01, 0x9a, 0x19, 0x3b, 0xb6, 0xdb, 0xb0, 0xb0, 0x2b, 0xf5, 0x36, 0xf3,
	0xbe, 0xcf, 0x3c, 0x7e, 0xde, 0x8f, 0x19, 0xbf, 0xc8, 0xe0, 0xe0, 0x07, 0x94, 0x70, 0xd2, 0x25,
	0xe3, 0x4d, 0x06, 0xf4, 0x04, 0xa8, 0x2d, 0xf7, 0xb8, 0x20, 0x3c, 0x8d, 0xe6, 0xd8, 0xeb, 0xb4,
	0x06, 0x84, 0x0c, 0xc6, 0xd0, 0x72, 0x03, 0xaf, 0xe5, 0xfa, 0x3e, 0xe1, 0x2e, 0xf7, 0x88, 0xcf,
	0x14, 0xae, 0xf1, 0x72, 0x0a, 0x21, 0x2d, 0x9d, 0xb0, 0xdf, 0x82, 0xe3, 0x80, 0x4f, 0x22, 0xc0,
	0x96, 0x00, 0xa8, 0x6f, 0x6c, 0x0e, 0xc0, 0xdf, 0x64, 0xa7, 0xee, 0x60, 0x00, 0xb4, 0x45, 0x02,
	0x49, 0x73, 0x95, 0xd2, 0xfa, 0x35, 0x8f, 0x9e, 0xbb, 0x47, 0xfc, 0xbe, 0x37, 0x08, 0xa9, 0x74,
	0xdc, 0x27, 0xdd, 0xf0, 0x18, 0x7c, 0x8e, 0x5f, 0x41, 0x8b, 0x2c, 0x0c, 0x02, 0x42, 0x39, 0x3b,
	0x7a, 0x18, 0x02, 0x9d, 0x18, 0x5a, 0x53, 0xdb, 0x28, 0x3b, 0xb5, 0xd8, 0xfa, 0xbe, 0x30, 0x0a,
	0x98, 0xf4, 0x1e, 0x81, 0xdf, 0x0b, 0x88, 0xe7, 0x73, 0x43, 0x6f, 0x6a, 0x1b, 0x15, 0xa7, 0x26,
	0xad, 0xfb, 0x91, 0x11, 0xbf, 0x8a, 0x96, 0x66, 0x6c, 0x61, 0x30, 0x26, 0x6e, 0xcf, 0xc8, 0x4b,
	0xba, 0xd9, 0x47, 0x3e, 0x90, 0x56, 0x01, 0x54, 0xfe, 0x84, 0xb0, 0x20, 0x09, 0x17, 0x95, 0x79,
	0xc6, 0x98, 0xd6, 0xd7, 0x07, 0xde, 0x1d, 0x1a, 0xc5, 0xac, 0xbe, 0xb7, 0x84, 0x51, 0xc0, 0xa4,
	0x37, 0xa1, 0x2b, 0x29, 0x7d, 0xd2, 0x3a, 0x57, 0x1f, 0x85, 0x13, 0x32, 0x02, 0x63, 0x21, 0xab,
	0xcf, 0x91, 0x56, 0x01, 0x54, 0xfe, 0x84, 0xb0, 0xac, 0xf4, 0x29, 0xf3, 0x8c, 0xf1, 0x35, 0xb4,
	0xc2, 0x87, 0x14, 0x5c, 0xce, 0x8e, 0x22, 0x0a, 0xe8, 0x19, 0x95, 0x66, 0x7e, 0xa3, 0xe2, 0x2c,
	0x47, 0x8e, 0x83, 0xd8, 0x2e, 0x54, 0x8e, 0x60, 0x92, 0x46, 0x22, 0x89, 0xac, 0x09, 0x6b, 0x02,
	0xdb, 0x46, 0xab, 0x2e, 0x63, 0x40, 0x65, 0x05, 0x53, 0xe0, 0xaa, 0x04, 0xd7, 0x13, 0xdf, 0xec,
	0x88, 0xb5, 0x8b, 0x2a, 0xf7, 0x3d, 0x77, 0xe0, 0x13, 0xe6, 0x31, 0xbc, 0x86, 0x4a, 0xea, 0xd3,
	0xb2, 0x96, 0x15, 0x27, 0xda, 0xe1, 0x17, 0x51, 0xa5, 0xa7, 0x40, 0xd0, 0x8b, 0xea, 0x97, 0x18,
	0xac, 0xbf, 0x34, 0x54, 0x53, 0xd5, 0x71, 0xe0, 0x61, 0x08, 0x8c, 0xe3, 0x9b, 0xa8, 0x3c, 0x82,
	0xc9, 0x11, 0x9f, 0x04, 0x10, 0x31, 0x2d, 0x8c, 0x60, 0x72, 0x38, 0x09, 0x00, 0x63, 0x54, 0x10,
	0x9a, 0x0d, 0x5d, 0x4a, 0x92, 0x6b, 0xbc, 0x39, 0xa3, 0xf7, 0x98, 0x2c, 0x7b, 0x75, 0x67, 0xc9,
	0x16, 0x3d, 0x6f, 0xcf, 0xa4, 0x39, 0x09, 0x02, 0xdf, 0x43, 0x28, 0x89, 0xc4, 0x28, 0x34, 0xf3,
	0x1b, 0xd5, 0x9d, 0x75, 0x85, 0xcf, 0xc8, 0xb0, 0x77, 0x67, 0xa8, 0x7d, 0x9f, 0xd3, 0x89, 0x93,
	0x3a, 0xd6, 0xb8, 0x8b, 0x96, 0x2e, 0xb9, 0xf1, 0x32, 0xca, 0x8f, 0x60, 0x12, 0x09, 0x16, 0x4b,
	0xbc, 0x8a, 0x8a, 0x27, 0xee, 0x38, 0x84, 0x28, 0x66, 0xb5, 0x69, 0xeb, 0xaf, 0x6b, 0xd6, 0x97,
	0x3a, 0xba, 0x21, 0x1b, 0xfc, 0x19, 0x43, 0x5e, 0x43, 0xa5, 0x0e, 0xf4, 0x09, 0x05, 0x19, 0x6f,
	0xc5, 0x89, 0x76, 0xe2, 0x8b, 0x6e, 0x9f, 0x03, 0x8d, 0x9a, 0x5a, 0x6d, 0x52, 0x75, 0x29, 0x66,
	0xea, 0xb2, 0x97, 0xc9, 0x44, 0x49, 0x66, 0xc2, 0x52, 0x99, 0x48, 0x8b, 0xbb, 0xce, 0x44, 0x7c,
	0xaf, 0xa3, 0x85, 0x0f, 0xa1, 0xf3, 0x8e, 0xe7, 0x8f, 0xc4, 0x39, 0x0a, 0xe3, 0xf8, 0x1c, 0x85,
	0xb1, 0x08, 0x5d, 0x66, 0x44, 0x1d, 0x93, 0x6b, 0x61, 0x1b, 0x52, 0xe8, 0x47, 0x81, 0xcb, 0x35,
	0xde, 0x46, 0x25, 0xee, 0xf1, 0x31, 0xc4, 0xe5, 0xbc, 0xa9, 0x82, 0x88, 0x88, 0xed, 0x43, 0xe9,
	0x53, 0xda, 0x23, 0x20, 0xbe, 0x8b, 0x50, 0x40, 0x49, 0x20, 0x84, 0x03, 0x33, 0x8a, 0xf2, 0xd8,
	0x4b, 0xd9, 0x63, 0xef, 0xcd, 0xfc, 0x51, 0xd8, 0xc9, 0x81, 0xc6, 0x1b, 0xa8, 0x9a, 0x62, 0x7d,
	0x9a, 0x90, 0x45, 0xc6, 0x2e, 0x31, 0x3f, 0x55, 0xc6, 0xfe, 0xd0, 0x50, 0x2d, 0xaa, 0x0e, 0x0b,
	0x88, 0xcf, 0xe0, 0x49, 0xbd, 0x63, 0xa0, 0x05, 0xf8, 0x24, 0x98, 0xdd, 0xbb, 0xb2, 0x13, 0x6f,
	0xc5, 0x9d, 0x94, 0xcb, 0x90, 0x82, 0xb8, 0x34, 0xa2, 0xb5, 0x12, 0x43, 0xaa, 0xbf, 0x0a, 0xf3,
	0xfb, 0xab, 0x38, 0xbf, 0xbf, 0x4a, 0x99, 0xfe, 0x32, 0xd0, 0xc2, 0x31, 0x30, 0xe6, 0x0e, 0xd4,
	0x6b, 0x57, 0x71, 0xe2, 0x2d, 0x5e, 0x47, 0xc5, 0xb1, 0xe7, 0x8f, 0x98, 0x51, 0x96, 0x89, 0xaf,
	0x65, 0x12, 0xef, 0x28, 0x9f, 0xf5, 0xb7, 0x86, 0x6e, 0xc8, 0x57, 0xf6, 0x7f, 0x5c, 0x92, 0x44,
	0xb0, 0x3e, 0x5f, 0x70, 0x7e, 0xbe, 0xe0, 0xc2, 0x13, 0x2e, 0x44, 0x31, 0x7d, 0x21, 0xd2, 0x42,
	0xae, 0xf3, 0x42, 0x7c, 0xa1, 0xa1, 0x5a, 0xf4, 0xad, 0xff, 0x2e, 0xef, 0xb5, 0x3d, 0x0d, 0xd6,
	0x0f, 0x1a, 0xaa, 0xa9, 0x5f, 0xd2, 0x33, 0xbe, 0x50, 0xd9, 0x57, 0x36, 0x9f, 0x7e, 0x65, 0x33,
	0xbc, 0xd7, 0x98, 0xcb, 0x9d, 0x9f, 0x75, 0x74, 0xeb, 0x50, 0xc6, 0xb3, 0x1f, 0x75, 0xf6, 0x03,
	0xc2, 0xbd, 0xbe, 0xd7, 0x95, 0xa3, 0xc8, 0x01, 0xd0, 0x13, 0xaf, 0x0b, 0xf8, 0x01, 0x2a, 0x45,
	0xc3, 0x41, 0x7d, 0xce, 0x5f, 0xa0, 0xb1, 0x66, 0xab, 0x91, 0xc8, 0x8e, 0x47, 0x22, 0x7b, 0x5f,
	0x8c, 0x44, 0xd6, 0xf3, 0x9f, 0xff, 0xf2, 0xfb, 0x37, 0xfa, 0x8a, 0x75, 0xa3, 0x25, 0x0e, 0xb5,
	0xd4, 0xf8, 0xd0, 0xd6, 0x6e, 0xe3, 0x7d, 0x54, 0x54, 0xb3, 0x0b, 0xbe, 0xfa, 0x94, 0x36, 0xea,
	0x19, 0x9b, 0xaa, 0xb0, 0x55, 0x97, 0x54, 0x35, 0xab, 0xaa, 0xa8, 0xe4, 0x68, 0x23, 0x68, 0xd4,
	0x88, 0x81, 0xaf, 0x36, 0x60, 0x4c, 0x93, 0x69, 0x94, 0xcb, 0x34, 0x72, 0x02, 0xc1, 0x6f, 0xa3,
	0x52, 0x34, 0x5a, 0xd4, 0xe7, 0x64, 0xff, 0x5f, 0xa3, 0x5b, 0x95, 0x5c, 0x8b, 0x71, 0x74, 0x6a,
	0xf8, 0xd8, 0xfb, 0x49, 0xff, 0x7a, 0xf7, 0x5b, 0x1d, 0x33, 0xb4, 0x75, 0x75, 0xd8, 0x6c, 0x37,
	0x55, 0xaa, 0x9b, 0x71, 0xae, 0x9b, 0xe9, 0x64, 0x5b, 0x6d, 0x54, 0x39, 0x38, 0xf5, 0x78, 0x77,
	0xd8, 0xf1, 0x38, 0x6e, 0x0c, 0x39, 0x0f, 0x58, 0xbb, 0xd5, 0x3a, 0x3d, 0x3d, 0xb5, 0x59, 0x6c,
	0xb6, 0xbb, 0xe4, 0xb8, 0xd5, 0x58, 0x71, 0x03, 0xef, 0xcd, 0x8c, 0x6d, 0x27, 0xbf, 0x6d, 0x6f,
	0x35, 0xaa, 0xdd, 0x9e, 0x6f, 0x77, 0xb6, 0xb7, 0x98, 0xed, 0x91, 0xdb, 0x9a, 0xbe, 0xb3, 0xec,
	0x06, 0xc1, 0x38, 0x62, 0x6f, 0x7d, 0xcc, 0x88, 0xdf, 0xbe, 0x62, 0xf9, 0x68, 0x1d, 0xdd, 0x42,
	0x68, 0x0f, 0x5c, 0x0a, 0x74, 0x37, 0xe4, 0x43, 0x5c, 0x2f, 0xeb, 0x8d, 0x9a, 0x58, 0x11, 0xea,
	0x7d, 0x2a, 0x71, 0x4d, 0xbd, 0xb3, 0x8c, 0x16, 0x33, 0xa0, 0x1c, 0xbd, 0x83, 0x56, 0xdf, 0x25,
	0x14, 0x9a, 0x6e, 0x87, 0x84, 0xbc, 0x99, 0xc8, 0x7e, 0x21, 0x96, 0xdd, 0x23, 0x5d, 0x76, 0x49,
	0xf7, 0xd9, 0xb9, 0x99, 0x7b, 0x74, 0x6e, 0xe6, 0x1e, 0x9f, 0x9b, 0xda, 0x67, 0x53, 0x53, 0xfb,
	0x6e, 0x6a, 0x6a, 0x3f, 0x4e, 0x4d, 0xed, 0x6c, 0x6a, 0x6a, 0xbf, 0x4d, 0x4d, 0xed, 0xcf, 0xa9,
	0x99, 0x7b, 0x3c, 0x35, 0xb5, 0xaf, 0x2e, 0xcc, 0xdc, 0xd9, 0x85, 0x99, 0x7b, 0x74, 0x61, 0xe6,
	0x3a, 0x25, 0x99, 0xc3, 0x3b, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xde, 0xcf, 0x49, 0x96, 0xbc,
	0x0b, 0x00, 0x00,
}

func (this *ConfigurationDocument) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConfigurationDocument)
	if !ok {
		that2, ok := that.(ConfigurationDocument)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SupportsQuery != that1.SupportsQuery {
		return false
	}
	if this.QueryEndpoint != that1.QueryEndpoint {
		return false
	}
	if this.SupportsUpload != that1.SupportsUpload {
		return false
	}
	if this.UploadEndpoint != that1.UploadEndpoint {
		return false
	}
	if this.SupportsFetch != that1.SupportsFetch {
		return false
	}
	if this.FetchEndpoint != that1.FetchEndpoint {
		return false
	}
	if this.SupportsRevoke != that1.SupportsRevoke {
		return false
	}
	if this.RevokeEndpoint != that1.RevokeEndpoint {
		return false
	}
	if len(this.ThreatsSupported) != len(that1.ThreatsSupported) {
		return false
	}
	for i := range this.ThreatsSupported {
		if this.ThreatsSupported[i] != that1.ThreatsSupported[i] {
			return false
		}
	}
	if len(this.KeysSupported) != len(that1.KeysSupported) {
		return false
	}
	for i := range this.KeysSupported {
		if this.KeysSupported[i] != that1.KeysSupported[i] {
			return false
		}
	}
	if len(this.AssertionsSupported) != len(that1.AssertionsSupported) {
		return false
	}
	for i := range this.AssertionsSupported {
		if this.AssertionsSupported[i] != that1.AssertionsSupported[i] {
			return false
		}
	}
	return true
}
func (this *Diagnosis) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Diagnosis)
	if !ok {
		that2, ok := that.(Diagnosis)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Threat != that1.Threat {
		return false
	}
	if this.Diagnosed != that1.Diagnosed {
		return false
	}
	return true
}
func (this *UploadRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadRequest)
	if !ok {
		that2, ok := that.(UploadRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.KeyType != that1.KeyType {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if this.Keys[i] != that1.Keys[i] {
			return false
		}
	}
	if !this.Diagnosis.Equal(that1.Diagnosis) {
		return false
	}
	if len(this.Assertions) != len(that1.Assertions) {
		return false
	}
	for i := range this.Assertions {
		if this.Assertions[i] != that1.Assertions[i] {
			return false
		}
	}
	return true
}
func (this *QueryRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryRequest)
	if !ok {
		that2, ok := that.(QueryRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.KeyType != that1.KeyType {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if this.Keys[i] != that1.Keys[i] {
			return false
		}
	}
	if this.Before != that1.Before {
		return false
	}
	if this.After != that1.After {
		return false
	}
	if this.Threat != that1.Threat {
		return false
	}
	if len(this.Assertions) != len(that1.Assertions) {
		return false
	}
	for i := range this.Assertions {
		if this.Assertions[i] != that1.Assertions[i] {
			return false
		}
	}
	return true
}
func (this *WebLink) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WebLink)
	if !ok {
		that2, ok := that.(WebLink)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Rel != that1.Rel {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Href != that1.Href {
		return false
	}
	if len(this.Titles) != len(that1.Titles) {
		return false
	}
	for i := range this.Titles {
		if this.Titles[i] != that1.Titles[i] {
			return false
		}
	}
	if len(this.Properties) != len(that1.Properties) {
		return false
	}
	for i := range this.Properties {
		if this.Properties[i] != that1.Properties[i] {
			return false
		}
	}
	return true
}
func (this *QueryResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryResponse)
	if !ok {
		that2, ok := that.(QueryResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.KeyType != that1.KeyType {
		return false
	}
	if this.Exposed != that1.Exposed {
		return false
	}
	if len(this.Exposures) != len(that1.Exposures) {
		return false
	}
	for i := range this.Exposures {
		if this.Exposures[i] != that1.Exposures[i] {
			return false
		}
	}
	if this.Before != that1.Before {
		return false
	}
	if this.After != that1.After {
		return false
	}
	if this.Threat != that1.Threat {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if len(this.Links) != len(that1.Links) {
		return false
	}
	for i := range this.Links {
		if !this.Links[i].Equal(that1.Links[i]) {
			return false
		}
	}
	return true
}
func (this *FetchRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FetchRequest)
	if !ok {
		that2, ok := that.(FetchRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.KeyType != that1.KeyType {
		return false
	}
	if this.Before != that1.Before {
		return false
	}
	if this.After != that1.After {
		return false
	}
	if this.Threat != that1.Threat {
		return false
	}
	if len(this.Assertions) != len(that1.Assertions) {
		return false
	}
	for i := range this.Assertions {
		if this.Assertions[i] != that1.Assertions[i] {
			return false
		}
	}
	return true
}
func (this *FetchResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FetchResponse)
	if !ok {
		that2, ok := that.(FetchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.KeyType != that1.KeyType {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if this.Keys[i] != that1.Keys[i] {
			return false
		}
	}
	if this.Before != that1.Before {
		return false
	}
	if this.After != that1.After {
		return false
	}
	if this.Threat != that1.Threat {
		return false
	}
	return true
}
func (this *RevokeRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RevokeRequest)
	if !ok {
		that2, ok := that.(RevokeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.KeyType != that1.KeyType {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if this.Keys[i] != that1.Keys[i] {
			return false
		}
	}
	if len(this.Assertions) != len(that1.Assertions) {
		return false
	}
	for i := range this.Assertions {
		if this.Assertions[i] != that1.Assertions[i] {
			return false
		}
	}
	return true
}
func (this *ConfigurationDocument) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&tenp.ConfigurationDocument{")
	s = append(s, "SupportsQuery: "+fmt.Sprintf("%#v", this.SupportsQuery)+",\n")
	s = append(s, "QueryEndpoint: "+fmt.Sprintf("%#v", this.QueryEndpoint)+",\n")
	s = append(s, "SupportsUpload: "+fmt.Sprintf("%#v", this.SupportsUpload)+",\n")
	s = append(s, "UploadEndpoint: "+fmt.Sprintf("%#v", this.UploadEndpoint)+",\n")
	s = append(s, "SupportsFetch: "+fmt.Sprintf("%#v", this.SupportsFetch)+",\n")
	s = append(s, "FetchEndpoint: "+fmt.Sprintf("%#v", this.FetchEndpoint)+",\n")
	s = append(s, "SupportsRevoke: "+fmt.Sprintf("%#v", this.SupportsRevoke)+",\n")
	s = append(s, "RevokeEndpoint: "+fmt.Sprintf("%#v", this.RevokeEndpoint)+",\n")
	s = append(s, "ThreatsSupported: "+fmt.Sprintf("%#v", this.ThreatsSupported)+",\n")
	s = append(s, "KeysSupported: "+fmt.Sprintf("%#v", this.KeysSupported)+",\n")
	s = append(s, "AssertionsSupported: "+fmt.Sprintf("%#v", this.AssertionsSupported)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Diagnosis) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tenp.Diagnosis{")
	s = append(s, "Threat: "+fmt.Sprintf("%#v", this.Threat)+",\n")
	s = append(s, "Diagnosed: "+fmt.Sprintf("%#v", this.Diagnosed)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tenp.UploadRequest{")
	s = append(s, "KeyType: "+fmt.Sprintf("%#v", this.KeyType)+",\n")
	s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	if this.Diagnosis != nil {
		s = append(s, "Diagnosis: "+fmt.Sprintf("%#v", this.Diagnosis)+",\n")
	}
	keysForAssertions := make([]string, 0, len(this.Assertions))
	for k, _ := range this.Assertions {
		keysForAssertions = append(keysForAssertions, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAssertions)
	mapStringForAssertions := "map[string]string{"
	for _, k := range keysForAssertions {
		mapStringForAssertions += fmt.Sprintf("%#v: %#v,", k, this.Assertions[k])
	}
	mapStringForAssertions += "}"
	if this.Assertions != nil {
		s = append(s, "Assertions: "+mapStringForAssertions+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueryRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&tenp.QueryRequest{")
	s = append(s, "KeyType: "+fmt.Sprintf("%#v", this.KeyType)+",\n")
	s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	s = append(s, "After: "+fmt.Sprintf("%#v", this.After)+",\n")
	s = append(s, "Threat: "+fmt.Sprintf("%#v", this.Threat)+",\n")
	keysForAssertions := make([]string, 0, len(this.Assertions))
	for k, _ := range this.Assertions {
		keysForAssertions = append(keysForAssertions, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAssertions)
	mapStringForAssertions := "map[string]string{"
	for _, k := range keysForAssertions {
		mapStringForAssertions += fmt.Sprintf("%#v: %#v,", k, this.Assertions[k])
	}
	mapStringForAssertions += "}"
	if this.Assertions != nil {
		s = append(s, "Assertions: "+mapStringForAssertions+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WebLink) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&tenp.WebLink{")
	s = append(s, "Rel: "+fmt.Sprintf("%#v", this.Rel)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Href: "+fmt.Sprintf("%#v", this.Href)+",\n")
	keysForTitles := make([]string, 0, len(this.Titles))
	for k, _ := range this.Titles {
		keysForTitles = append(keysForTitles, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTitles)
	mapStringForTitles := "map[string]string{"
	for _, k := range keysForTitles {
		mapStringForTitles += fmt.Sprintf("%#v: %#v,", k, this.Titles[k])
	}
	mapStringForTitles += "}"
	if this.Titles != nil {
		s = append(s, "Titles: "+mapStringForTitles+",\n")
	}
	keysForProperties := make([]string, 0, len(this.Properties))
	for k, _ := range this.Properties {
		keysForProperties = append(keysForProperties, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForProperties)
	mapStringForProperties := "map[string]string{"
	for _, k := range keysForProperties {
		mapStringForProperties += fmt.Sprintf("%#v: %#v,", k, this.Properties[k])
	}
	mapStringForProperties += "}"
	if this.Properties != nil {
		s = append(s, "Properties: "+mapStringForProperties+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueryResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&tenp.QueryResponse{")
	s = append(s, "KeyType: "+fmt.Sprintf("%#v", this.KeyType)+",\n")
	s = append(s, "Exposed: "+fmt.Sprintf("%#v", this.Exposed)+",\n")
	s = append(s, "Exposures: "+fmt.Sprintf("%#v", this.Exposures)+",\n")
	s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	s = append(s, "After: "+fmt.Sprintf("%#v", this.After)+",\n")
	s = append(s, "Threat: "+fmt.Sprintf("%#v", this.Threat)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Links != nil {
		s = append(s, "Links: "+fmt.Sprintf("%#v", this.Links)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FetchRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&tenp.FetchRequest{")
	s = append(s, "KeyType: "+fmt.Sprintf("%#v", this.KeyType)+",\n")
	s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	s = append(s, "After: "+fmt.Sprintf("%#v", this.After)+",\n")
	s = append(s, "Threat: "+fmt.Sprintf("%#v", this.Threat)+",\n")
	keysForAssertions := make([]string, 0, len(this.Assertions))
	for k, _ := range this.Assertions {
		keysForAssertions = append(keysForAssertions, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAssertions)
	mapStringForAssertions := "map[string]string{"
	for _, k := range keysForAssertions {
		mapStringForAssertions += fmt.Sprintf("%#v: %#v,", k, this.Assertions[k])
	}
	mapStringForAssertions += "}"
	if this.Assertions != nil {
		s = append(s, "Assertions: "+mapStringForAssertions+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FetchResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&tenp.FetchResponse{")
	s = append(s, "KeyType: "+fmt.Sprintf("%#v", this.KeyType)+",\n")
	s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	s = append(s, "After: "+fmt.Sprintf("%#v", this.After)+",\n")
	s = append(s, "Threat: "+fmt.Sprintf("%#v", this.Threat)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RevokeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tenp.RevokeRequest{")
	s = append(s, "KeyType: "+fmt.Sprintf("%#v", this.KeyType)+",\n")
	s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	keysForAssertions := make([]string, 0, len(this.Assertions))
	for k, _ := range this.Assertions {
		keysForAssertions = append(keysForAssertions, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAssertions)
	mapStringForAssertions := "map[string]string{"
	for _, k := range keysForAssertions {
		mapStringForAssertions += fmt.Sprintf("%#v: %#v,", k, this.Assertions[k])
	}
	mapStringForAssertions += "}"
	if this.Assertions != nil {
		s = append(s, "Assertions: "+mapStringForAssertions+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTenprotocolServer(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ThreatExposureNotificationServiceClient is the client API for ThreatExposureNotificationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ThreatExposureNotificationServiceClient interface {
	Upload(ctx context.Context, in *UploadRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error)
	Fetch(ctx context.Context, in *FetchRequest, opts ...grpc.CallOption) (*FetchResponse, error)
	Revoke(ctx context.Context, in *RevokeRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type threatExposureNotificationServiceClient struct {
	cc *grpc.ClientConn
}

func NewThreatExposureNotificationServiceClient(cc *grpc.ClientConn) ThreatExposureNotificationServiceClient {
	return &threatExposureNotificationServiceClient{cc}
}

func (c *threatExposureNotificationServiceClient) Upload(ctx context.Context, in *UploadRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tenp.ThreatExposureNotificationService/Upload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *threatExposureNotificationServiceClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := c.cc.Invoke(ctx, "/tenp.ThreatExposureNotificationService/Query", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *threatExposureNotificationServiceClient) Fetch(ctx context.Context, in *FetchRequest, opts ...grpc.CallOption) (*FetchResponse, error) {
	out := new(FetchResponse)
	err := c.cc.Invoke(ctx, "/tenp.ThreatExposureNotificationService/Fetch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *threatExposureNotificationServiceClient) Revoke(ctx context.Context, in *RevokeRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tenp.ThreatExposureNotificationService/Revoke", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ThreatExposureNotificationServiceServer is the server API for ThreatExposureNotificationService service.
type ThreatExposureNotificationServiceServer interface {
	Upload(context.Context, *UploadRequest) (*empty.Empty, error)
	Query(context.Context, *QueryRequest) (*QueryResponse, error)
	Fetch(context.Context, *FetchRequest) (*FetchResponse, error)
	Revoke(context.Context, *RevokeRequest) (*empty.Empty, error)
}

// UnimplementedThreatExposureNotificationServiceServer can be embedded to have forward compatible implementations.
type UnimplementedThreatExposureNotificationServiceServer struct {
}

func (*UnimplementedThreatExposureNotificationServiceServer) Upload(ctx context.Context, req *UploadRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upload not implemented")
}
func (*UnimplementedThreatExposureNotificationServiceServer) Query(ctx context.Context, req *QueryRequest) (*QueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (*UnimplementedThreatExposureNotificationServiceServer) Fetch(ctx context.Context, req *FetchRequest) (*FetchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Fetch not implemented")
}
func (*UnimplementedThreatExposureNotificationServiceServer) Revoke(ctx context.Context, req *RevokeRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Revoke not implemented")
}

func RegisterThreatExposureNotificationServiceServer(s *grpc.Server, srv ThreatExposureNotificationServiceServer) {
	s.RegisterService(&_ThreatExposureNotificationService_serviceDesc, srv)
}

func _ThreatExposureNotificationService_Upload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ThreatExposureNotificationServiceServer).Upload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tenp.ThreatExposureNotificationService/Upload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ThreatExposureNotificationServiceServer).Upload(ctx, req.(*UploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ThreatExposureNotificationService_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ThreatExposureNotificationServiceServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tenp.ThreatExposureNotificationService/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ThreatExposureNotificationServiceServer).Query(ctx, req.(*QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ThreatExposureNotificationService_Fetch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ThreatExposureNotificationServiceServer).Fetch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tenp.ThreatExposureNotificationService/Fetch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ThreatExposureNotificationServiceServer).Fetch(ctx, req.(*FetchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ThreatExposureNotificationService_Revoke_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ThreatExposureNotificationServiceServer).Revoke(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tenp.ThreatExposureNotificationService/Revoke",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ThreatExposureNotificationServiceServer).Revoke(ctx, req.(*RevokeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ThreatExposureNotificationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tenp.ThreatExposureNotificationService",
	HandlerType: (*ThreatExposureNotificationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Upload",
			Handler:    _ThreatExposureNotificationService_Upload_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _ThreatExposureNotificationService_Query_Handler,
		},
		{
			MethodName: "Fetch",
			Handler:    _ThreatExposureNotificationService_Fetch_Handler,
		},
		{
			MethodName: "Revoke",
			Handler:    _ThreatExposureNotificationService_Revoke_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tenprotocol-server.proto",
}

func (m *ConfigurationDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigurationDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigurationDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssertionsSupported) > 0 {
		for iNdEx := len(m.AssertionsSupported) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AssertionsSupported[iNdEx])
			copy(dAtA[i:], m.AssertionsSupported[iNdEx])
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.AssertionsSupported[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.KeysSupported) > 0 {
		for iNdEx := len(m.KeysSupported) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeysSupported[iNdEx])
			copy(dAtA[i:], m.KeysSupported[iNdEx])
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.KeysSupported[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.ThreatsSupported) > 0 {
		for iNdEx := len(m.ThreatsSupported) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ThreatsSupported[iNdEx])
			copy(dAtA[i:], m.ThreatsSupported[iNdEx])
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.ThreatsSupported[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.RevokeEndpoint) > 0 {
		i -= len(m.RevokeEndpoint)
		copy(dAtA[i:], m.RevokeEndpoint)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.RevokeEndpoint)))
		i--
		dAtA[i] = 0x42
	}
	if m.SupportsRevoke {
		i--
		if m.SupportsRevoke {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.FetchEndpoint) > 0 {
		i -= len(m.FetchEndpoint)
		copy(dAtA[i:], m.FetchEndpoint)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.FetchEndpoint)))
		i--
		dAtA[i] = 0x32
	}
	if m.SupportsFetch {
		i--
		if m.SupportsFetch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.UploadEndpoint) > 0 {
		i -= len(m.UploadEndpoint)
		copy(dAtA[i:], m.UploadEndpoint)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.UploadEndpoint)))
		i--
		dAtA[i] = 0x22
	}
	if m.SupportsUpload {
		i--
		if m.SupportsUpload {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.QueryEndpoint) > 0 {
		i -= len(m.QueryEndpoint)
		copy(dAtA[i:], m.QueryEndpoint)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.QueryEndpoint)))
		i--
		dAtA[i] = 0x12
	}
	if m.SupportsQuery {
		i--
		if m.SupportsQuery {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Diagnosis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Diagnosis) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Diagnosis) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Diagnosed) > 0 {
		i -= len(m.Diagnosed)
		copy(dAtA[i:], m.Diagnosed)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Diagnosed)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Threat) > 0 {
		i -= len(m.Threat)
		copy(dAtA[i:], m.Threat)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Threat)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Assertions) > 0 {
		for k := range m.Assertions {
			v := m.Assertions[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Diagnosis != nil {
		{
			size, err := m.Diagnosis.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.KeyType) > 0 {
		i -= len(m.KeyType)
		copy(dAtA[i:], m.KeyType)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.KeyType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Assertions) > 0 {
		for k := range m.Assertions {
			v := m.Assertions[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Threat) > 0 {
		i -= len(m.Threat)
		copy(dAtA[i:], m.Threat)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Threat)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.After) > 0 {
		i -= len(m.After)
		copy(dAtA[i:], m.After)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.After)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Before) > 0 {
		i -= len(m.Before)
		copy(dAtA[i:], m.Before)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Before)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.KeyType) > 0 {
		i -= len(m.KeyType)
		copy(dAtA[i:], m.KeyType)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.KeyType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WebLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebLink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebLink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Titles) > 0 {
		for k := range m.Titles {
			v := m.Titles[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Href) > 0 {
		i -= len(m.Href)
		copy(dAtA[i:], m.Href)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Href)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Rel) > 0 {
		i -= len(m.Rel)
		copy(dAtA[i:], m.Rel)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Rel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Links) > 0 {
		for iNdEx := len(m.Links) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Links[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTenprotocolServer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Threat) > 0 {
		i -= len(m.Threat)
		copy(dAtA[i:], m.Threat)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Threat)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.After) > 0 {
		i -= len(m.After)
		copy(dAtA[i:], m.After)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.After)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Before) > 0 {
		i -= len(m.Before)
		copy(dAtA[i:], m.Before)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Before)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Exposures) > 0 {
		for iNdEx := len(m.Exposures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Exposures[iNdEx])
			copy(dAtA[i:], m.Exposures[iNdEx])
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Exposures[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Exposed {
		i--
		if m.Exposed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.KeyType) > 0 {
		i -= len(m.KeyType)
		copy(dAtA[i:], m.KeyType)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.KeyType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Assertions) > 0 {
		for k := range m.Assertions {
			v := m.Assertions[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Threat) > 0 {
		i -= len(m.Threat)
		copy(dAtA[i:], m.Threat)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Threat)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.After) > 0 {
		i -= len(m.After)
		copy(dAtA[i:], m.After)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.After)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Before) > 0 {
		i -= len(m.Before)
		copy(dAtA[i:], m.Before)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Before)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeyType) > 0 {
		i -= len(m.KeyType)
		copy(dAtA[i:], m.KeyType)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.KeyType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Threat) > 0 {
		i -= len(m.Threat)
		copy(dAtA[i:], m.Threat)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Threat)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.After) > 0 {
		i -= len(m.After)
		copy(dAtA[i:], m.After)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.After)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Before) > 0 {
		i -= len(m.Before)
		copy(dAtA[i:], m.Before)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Before)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.KeyType) > 0 {
		i -= len(m.KeyType)
		copy(dAtA[i:], m.KeyType)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.KeyType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RevokeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RevokeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RevokeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Assertions) > 0 {
		for k := range m.Assertions {
			v := m.Assertions[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.KeyType) > 0 {
		i -= len(m.KeyType)
		copy(dAtA[i:], m.KeyType)
		i = encodeVarintTenprotocolServer(dAtA, i, uint64(len(m.KeyType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTenprotocolServer(dAtA []byte, offset int, v uint64) int {
	offset -= sovTenprotocolServer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ConfigurationDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SupportsQuery {
		n += 2
	}
	l = len(m.QueryEndpoint)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	if m.SupportsUpload {
		n += 2
	}
	l = len(m.UploadEndpoint)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	if m.SupportsFetch {
		n += 2
	}
	l = len(m.FetchEndpoint)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	if m.SupportsRevoke {
		n += 2
	}
	l = len(m.RevokeEndpoint)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	if len(m.ThreatsSupported) > 0 {
		for _, s := range m.ThreatsSupported {
			l = len(s)
			n += 1 + l + sovTenprotocolServer(uint64(l))
		}
	}
	if len(m.KeysSupported) > 0 {
		for _, s := range m.KeysSupported {
			l = len(s)
			n += 1 + l + sovTenprotocolServer(uint64(l))
		}
	}
	if len(m.AssertionsSupported) > 0 {
		for _, s := range m.AssertionsSupported {
			l = len(s)
			n += 1 + l + sovTenprotocolServer(uint64(l))
		}
	}
	return n
}

func (m *Diagnosis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Threat)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	l = len(m.Diagnosed)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	return n
}

func (m *UploadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyType)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovTenprotocolServer(uint64(l))
		}
	}
	if m.Diagnosis != nil {
		l = m.Diagnosis.Size()
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	if len(m.Assertions) > 0 {
		for k, v := range m.Assertions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTenprotocolServer(uint64(len(k))) + 1 + len(v) + sovTenprotocolServer(uint64(len(v)))
			n += mapEntrySize + 1 + sovTenprotocolServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *QueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyType)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovTenprotocolServer(uint64(l))
		}
	}
	l = len(m.Before)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	l = len(m.After)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	l = len(m.Threat)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	if len(m.Assertions) > 0 {
		for k, v := range m.Assertions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTenprotocolServer(uint64(len(k))) + 1 + len(v) + sovTenprotocolServer(uint64(len(v)))
			n += mapEntrySize + 1 + sovTenprotocolServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *WebLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Rel)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	l = len(m.Href)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	if len(m.Titles) > 0 {
		for k, v := range m.Titles {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTenprotocolServer(uint64(len(k))) + 1 + len(v) + sovTenprotocolServer(uint64(len(v)))
			n += mapEntrySize + 1 + sovTenprotocolServer(uint64(mapEntrySize))
		}
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTenprotocolServer(uint64(len(k))) + 1 + len(v) + sovTenprotocolServer(uint64(len(v)))
			n += mapEntrySize + 1 + sovTenprotocolServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *QueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyType)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	if m.Exposed {
		n += 2
	}
	if len(m.Exposures) > 0 {
		for _, s := range m.Exposures {
			l = len(s)
			n += 1 + l + sovTenprotocolServer(uint64(l))
		}
	}
	l = len(m.Before)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	l = len(m.After)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	l = len(m.Threat)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	if len(m.Links) > 0 {
		for _, e := range m.Links {
			l = e.Size()
			n += 1 + l + sovTenprotocolServer(uint64(l))
		}
	}
	return n
}

func (m *FetchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyType)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	l = len(m.Before)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	l = len(m.After)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	l = len(m.Threat)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	if len(m.Assertions) > 0 {
		for k, v := range m.Assertions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTenprotocolServer(uint64(len(k))) + 1 + len(v) + sovTenprotocolServer(uint64(len(v)))
			n += mapEntrySize + 1 + sovTenprotocolServer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FetchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyType)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovTenprotocolServer(uint64(l))
		}
	}
	l = len(m.Before)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	l = len(m.After)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	l = len(m.Threat)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	return n
}

func (m *RevokeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyType)
	if l > 0 {
		n += 1 + l + sovTenprotocolServer(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovTenprotocolServer(uint64(l))
		}
	}
	if len(m.Assertions) > 0 {
		for k, v := range m.Assertions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTenprotocolServer(uint64(len(k))) + 1 + len(v) + sovTenprotocolServer(uint64(len(v)))
			n += mapEntrySize + 1 + sovTenprotocolServer(uint64(mapEntrySize))
		}
	}
	return n
}

func sovTenprotocolServer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTenprotocolServer(x uint64) (n int) {
	return sovTenprotocolServer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ConfigurationDocument) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConfigurationDocument{`,
		`SupportsQuery:` + fmt.Sprintf("%v", this.SupportsQuery) + `,`,
		`QueryEndpoint:` + fmt.Sprintf("%v", this.QueryEndpoint) + `,`,
		`SupportsUpload:` + fmt.Sprintf("%v", this.SupportsUpload) + `,`,
		`UploadEndpoint:` + fmt.Sprintf("%v", this.UploadEndpoint) + `,`,
		`SupportsFetch:` + fmt.Sprintf("%v", this.SupportsFetch) + `,`,
		`FetchEndpoint:` + fmt.Sprintf("%v", this.FetchEndpoint) + `,`,
		`SupportsRevoke:` + fmt.Sprintf("%v", this.SupportsRevoke) + `,`,
		`RevokeEndpoint:` + fmt.Sprintf("%v", this.RevokeEndpoint) + `,`,
		`ThreatsSupported:` + fmt.Sprintf("%v", this.ThreatsSupported) + `,`,
		`KeysSupported:` + fmt.Sprintf("%v", this.KeysSupported) + `,`,
		`AssertionsSupported:` + fmt.Sprintf("%v", this.AssertionsSupported) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Diagnosis) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Diagnosis{`,
		`Threat:` + fmt.Sprintf("%v", this.Threat) + `,`,
		`Diagnosed:` + fmt.Sprintf("%v", this.Diagnosed) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAssertions := make([]string, 0, len(this.Assertions))
	for k, _ := range this.Assertions {
		keysForAssertions = append(keysForAssertions, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAssertions)
	mapStringForAssertions := "map[string]string{"
	for _, k := range keysForAssertions {
		mapStringForAssertions += fmt.Sprintf("%v: %v,", k, this.Assertions[k])
	}
	mapStringForAssertions += "}"
	s := strings.Join([]string{`&UploadRequest{`,
		`KeyType:` + fmt.Sprintf("%v", this.KeyType) + `,`,
		`Keys:` + fmt.Sprintf("%v", this.Keys) + `,`,
		`Diagnosis:` + strings.Replace(this.Diagnosis.String(), "Diagnosis", "Diagnosis", 1) + `,`,
		`Assertions:` + mapStringForAssertions + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAssertions := make([]string, 0, len(this.Assertions))
	for k, _ := range this.Assertions {
		keysForAssertions = append(keysForAssertions, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAssertions)
	mapStringForAssertions := "map[string]string{"
	for _, k := range keysForAssertions {
		mapStringForAssertions += fmt.Sprintf("%v: %v,", k, this.Assertions[k])
	}
	mapStringForAssertions += "}"
	s := strings.Join([]string{`&QueryRequest{`,
		`KeyType:` + fmt.Sprintf("%v", this.KeyType) + `,`,
		`Keys:` + fmt.Sprintf("%v", this.Keys) + `,`,
		`Before:` + fmt.Sprintf("%v", this.Before) + `,`,
		`After:` + fmt.Sprintf("%v", this.After) + `,`,
		`Threat:` + fmt.Sprintf("%v", this.Threat) + `,`,
		`Assertions:` + mapStringForAssertions + `,`,
		`}`,
	}, "")
	return s
}
func (this *WebLink) String() string {
	if this == nil {
		return "nil"
	}
	keysForTitles := make([]string, 0, len(this.Titles))
	for k, _ := range this.Titles {
		keysForTitles = append(keysForTitles, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTitles)
	mapStringForTitles := "map[string]string{"
	for _, k := range keysForTitles {
		mapStringForTitles += fmt.Sprintf("%v: %v,", k, this.Titles[k])
	}
	mapStringForTitles += "}"
	keysForProperties := make([]string, 0, len(this.Properties))
	for k, _ := range this.Properties {
		keysForProperties = append(keysForProperties, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForProperties)
	mapStringForProperties := "map[string]string{"
	for _, k := range keysForProperties {
		mapStringForProperties += fmt.Sprintf("%v: %v,", k, this.Properties[k])
	}
	mapStringForProperties += "}"
	s := strings.Join([]string{`&WebLink{`,
		`Rel:` + fmt.Sprintf("%v", this.Rel) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Href:` + fmt.Sprintf("%v", this.Href) + `,`,
		`Titles:` + mapStringForTitles + `,`,
		`Properties:` + mapStringForProperties + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLinks := "[]*WebLink{"
	for _, f := range this.Links {
		repeatedStringForLinks += strings.Replace(f.String(), "WebLink", "WebLink", 1) + ","
	}
	repeatedStringForLinks += "}"
	s := strings.Join([]string{`&QueryResponse{`,
		`KeyType:` + fmt.Sprintf("%v", this.KeyType) + `,`,
		`Exposed:` + fmt.Sprintf("%v", this.Exposed) + `,`,
		`Exposures:` + fmt.Sprintf("%v", this.Exposures) + `,`,
		`Before:` + fmt.Sprintf("%v", this.Before) + `,`,
		`After:` + fmt.Sprintf("%v", this.After) + `,`,
		`Threat:` + fmt.Sprintf("%v", this.Threat) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`Links:` + repeatedStringForLinks + `,`,
		`}`,
	}, "")
	return s
}
func (this *FetchRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAssertions := make([]string, 0, len(this.Assertions))
	for k, _ := range this.Assertions {
		keysForAssertions = append(keysForAssertions, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAssertions)
	mapStringForAssertions := "map[string]string{"
	for _, k := range keysForAssertions {
		mapStringForAssertions += fmt.Sprintf("%v: %v,", k, this.Assertions[k])
	}
	mapStringForAssertions += "}"
	s := strings.Join([]string{`&FetchRequest{`,
		`KeyType:` + fmt.Sprintf("%v", this.KeyType) + `,`,
		`Before:` + fmt.Sprintf("%v", this.Before) + `,`,
		`After:` + fmt.Sprintf("%v", this.After) + `,`,
		`Threat:` + fmt.Sprintf("%v", this.Threat) + `,`,
		`Assertions:` + mapStringForAssertions + `,`,
		`}`,
	}, "")
	return s
}
func (this *FetchResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FetchResponse{`,
		`KeyType:` + fmt.Sprintf("%v", this.KeyType) + `,`,
		`Keys:` + fmt.Sprintf("%v", this.Keys) + `,`,
		`Before:` + fmt.Sprintf("%v", this.Before) + `,`,
		`After:` + fmt.Sprintf("%v", this.After) + `,`,
		`Threat:` + fmt.Sprintf("%v", this.Threat) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RevokeRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAssertions := make([]string, 0, len(this.Assertions))
	for k, _ := range this.Assertions {
		keysForAssertions = append(keysForAssertions, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAssertions)
	mapStringForAssertions := "map[string]string{"
	for _, k := range keysForAssertions {
		mapStringForAssertions += fmt.Sprintf("%v: %v,", k, this.Assertions[k])
	}
	mapStringForAssertions += "}"
	s := strings.Join([]string{`&RevokeRequest{`,
		`KeyType:` + fmt.Sprintf("%v", this.KeyType) + `,`,
		`Keys:` + fmt.Sprintf("%v", this.Keys) + `,`,
		`Assertions:` + mapStringForAssertions + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTenprotocolServer(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ConfigurationDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTenprotocolServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigurationDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigurationDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsQuery", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsQuery = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsUpload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsUpload = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsFetch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsFetch = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FetchEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsRevoke", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsRevoke = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevokeEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RevokeEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreatsSupported", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThreatsSupported = append(m.ThreatsSupported, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysSupported", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeysSupported = append(m.KeysSupported, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssertionsSupported", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssertionsSupported = append(m.AssertionsSupported, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Diagnosis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTenprotocolServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Diagnosis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Diagnosis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Threat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diagnosed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Diagnosed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTenprotocolServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diagnosis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Diagnosis == nil {
				m.Diagnosis = &Diagnosis{}
			}
			if err := m.Diagnosis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assertions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Assertions == nil {
				m.Assertions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTenprotocolServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTenprotocolServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTenprotocolServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Assertions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTenprotocolServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Before = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.After = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Threat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assertions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Assertions == nil {
				m.Assertions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTenprotocolServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTenprotocolServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTenprotocolServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Assertions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTenprotocolServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Href", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Href = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Titles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Titles == nil {
				m.Titles = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTenprotocolServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTenprotocolServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTenprotocolServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Titles[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTenprotocolServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTenprotocolServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTenprotocolServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTenprotocolServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exposed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exposed = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exposures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exposures = append(m.Exposures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Before = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.After = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Threat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, &WebLink{})
			if err := m.Links[len(m.Links)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTenprotocolServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Before = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.After = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Threat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assertions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Assertions == nil {
				m.Assertions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTenprotocolServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTenprotocolServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTenprotocolServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Assertions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTenprotocolServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Before = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.After = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Threat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevokeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTenprotocolServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevokeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevokeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assertions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Assertions == nil {
				m.Assertions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTenprotocolServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTenprotocolServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTenprotocolServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTenprotocolServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Assertions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTenprotocolServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTenprotocolServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTenprotocolServer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTenprotocolServer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTenprotocolServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTenprotocolServer
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTenprotocolServer
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTenprotocolServer
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTenprotocolServer        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTenprotocolServer          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTenprotocolServer = fmt.Errorf("proto: unexpected end of group")
)
